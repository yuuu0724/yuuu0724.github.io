[{"title":"操作系统笔记-Chapter 1-概论","url":"/2026/02/03/OS-chapter-1/","content":"操作系统的启动\nDISK：存放OS和Bootloader。一开始操作系统并不是直接放入内存里面，而是放到硬盘当中，由BIOS来提供支持。\n\nBIOS：基本IO处理系统。计算机开机之后，让计算机系统检测各种外设，让OS加载相应软件。\n\nBootloader：加载OS，把OS从硬盘放到内存中，使得CPU能够执行操作系统。\n\n\n\n\n\nBOIS会在内存的特定地址开始执行。\n上电之后BOIS需要执行的操作：\n\nPOST（加电自检），检查设备是否能正常工作。\n将Bootloader从硬盘放到内存中。\n寻找显卡和执行BIOS\n\n\nBootloader：\n\n寻找DISK中操作系统的起始扇区和操作系统长度。\n将操作系统对应磁盘块读到内存中。\n将CPU控制权交给OS，跳转到操作系统的起始地址执行。\n\n\n操作系统的系统调用、异常、中断定义：\n1.系统调用（来源于应用程序）\n​\t异步或者同步事件。应用程序主动向操作系统发出服务请求。\n2.异常（来源于不良的应用程序）\n​\t同步事件。非法指令或者其他坏的处理状态（如：内存出错），并非程序主动发出的请求。\n3.中断（来源于外设）\n​\t异步事件。来自不同硬件设备的计时器和网络中断。\n系统调用、中断和异常的处理机制\n中断：\n​\t硬件：\n​\t设置中断标记\n​\t\t1.将内部、外部事件设置中断标记\n​\t\t2.设置中断事件的ID，让操作系统能找到对应的处理程序\n​\t软件：\n​\t1.保存当前的处理状态，当中断服务程序执行完成后回到原来被打断的点。\n​\t2.保存完状态后，程序跳转到中断号对应的中断服务程序。\n​\t3.清除中断标记\n​\t4.恢复原本的处理状态\n异常：\n1.保存现场\n2.异常处理\n​\t1.杀死产生异常的程序\n​\t2.重新执行异常的程序\n3.恢复现场\n系统调用：\n程序访问只要是通过高层次的API接口而不是直接进行系统调用。Linux，Mac OS等用的是POSIX API，只要遵循这个机制，就可以跨平台使用。\n应用程序会通过Library Code来访问系统调用接口。\n访问到系统调用接口过后会触发操作系统从用户态转换为内核态。\n**用户态：**特权低，无法直接访问特殊的机器指令和IO。\n**内核态：**操作系统运行过程中可以执行任意一条CPU发出的指令，包括特权指令和访问IO的指令。可以完全控制整个计算机系统。\n转换为内核态后，操作系统会识别应用程序发出的系统调用参数、ID号等，并完成具体的服务。\n系统调用和函数调用的区别：\n​\t1.函数调用只是在一个栈空间中进行参数的传递，参数的返回\n​\t2.系统调用中，应用程序和操作系统内核拥有各自的堆栈。当应用程序发出系统调用后，需要切换堆栈，同时要完成特权转换。\n可见执行系统调用相比于执行函数调用开销要大很多，但是系统调用要可靠得多。\n","categories":["操作系统"],"tags":["操作系统","笔记"]},{"title":"操作系统笔记-Chapter 2-内存","url":"/2026/02/03/OS-chapter-2/","content":"1.内存分层寄存器-缓存-主存-磁盘（虚拟内存）速度由快到慢。\n\n操作系统中管理内存的不同方法\n程序重定位\n分段\n分页\n虚拟内存\n按需分页虚拟内存\n\n\n\n\n\n\n2.地址空间&amp;地址生成1.地址空间定义：物理地址空间：与硬件直接对应，如内存条、硬盘等，其管理和控制由硬件完成。\n逻辑地址空间：一个程序运行时的地址空间，相较于物理地址空间更简单，需通过操作系统将程序映射到物理地址空间。\n\nc语言和汇编语言都是人能看懂的，不带有地址，而链接文件和可执行文件中包含地址。这些地址都是逻辑地址，知识通过编译器等完成的，还没有经过操作系统。\n2.地址空间的生成​\tCPU 内部包含一个 内存管理单元 (MMU)，它负责将程序运行时产生的 逻辑地址 (Logical Address) 实时转换成内存中的 物理地址 (Physical Address)。\n​\t当 CPU 需要执行一条指令时，它会向 MMU 发出逻辑地址。MMU 通过查询由操作系统维护的 页表 (Page Table) 或 段表 (Segment Table) 等映射机制，找到该逻辑地址对应的物理地址。\n​\t获取到物理地址后，CPU 控制器（或总线接口单元）会通过 系统总线 向 主存储器 (Main Memory) 发送请求，请求获取该物理地址处存储的内容（即待执行的指令或数据）。\n​\t主存接收到请求后，将相应物理地址的内容通过总线传输回 CPU。CPU 接收到指令后，便开始执行。\n​\t操作系统 (OS) 在整个过程中扮演的关键角色是 建立和维护 这种逻辑地址到物理地址的 映射关系，确保每个进程都能安全、独立地访问其所需的内存空间。\n3.连续内存分配1.内存碎片给运行的程序分配空间之后，会出现一些无法利用的空闲空间。\n内碎片：分配单元之内使用的剩余内存空间。\n外碎片：分配单元之间未使用的内存空间\n2.动态分配操作系统把程序加载到内存中去，也就是在内存中分配一块连续的区域，让程序能成功运行。\n程序运行时需要访问数据，操作系统需要给数据分配地址空间。\n分配策略：\n\n首次分配\n\n最优分配\n\n最差适配\n\n\n**首次适配：**按顺序从第一个空闲内存块开始找\n\n\n将空闲块按地址排序\n寻找第一个合适的分区\n\n优点：简单、易于产生大的空闲块\n缺点：容易产生外部碎片\n**最优适配：**寻找整个地址空间中，最满足分配请求的空间块\n\n\n按尺寸排列空闲块列表\n寻找最适合的分区\n\n优点：当分配是小尺寸是非常有效\n缺点：容易产生微小的外部碎片\n**最差适配：**寻找整个地址空间中，与分配需求差距最大的地址空间\n\n\n按尺寸排列空闲块的列表\n寻找最大的分区\n\n优点：分配中等尺寸效果最好\n缺点：外部碎片、容易破坏打的空闲块以至于大空闲块无法被分配。\n3.压缩式与交换式碎片整理由于无论采用什么算法都会产生一定的内碎片和外碎片，故需要一个处理方法使得碎片尽量的少。\n处理方法：\n\n压缩式碎片整理\n交换式碎片整理\n\n压缩式碎片整理：调整程序位置，合并未使用的空间\n\n交换式碎片整理：\n充分利用硬盘。当程序快把内存空间占满时，没有多余空闲空间，无法使用压缩式整理碎片。此时把硬盘当作备份。\n问题：①把哪个程序换到硬盘？②什么时候进行换入换出？\n","categories":["操作系统"],"tags":["操作系统","笔记"]},{"title":"Git push文件操作","url":"/2026/02/04/Git%E6%93%8D%E4%BD%9C/","content":"Git push文件操作1.生成密钥,运行下列命令一路回车ssh-keygen -t rsa\n\n在.ssh文件夹中打开id_rsa.pub，复制全部内容到GitHub的ssh配置中\n\n\n2.创建本地仓库在文件夹下右键git bash here\n运行命令\ngit init\n\n此时会出现master分支，由于GitHub默认分支是main，故使用以下命令将分支改为main\ngit branch -M main\n\n3.创建远程仓库在GitHub中创建远程仓库，复制ssh链接\n4.关联远程和本地仓库git remote add origin  远程仓库的URL\n\n添加远程仓库后，可以使用git branch -a命令查看所有分支，其中-a选项用于显示本地和远程所有分支。\n5.上传代码1.将代码添加到暂存区git add .\n\n2.将代码添加到本地仓库，写入更新说明git commit -m &#x27;更新说明&#x27;\n\n3.将代码push到远程仓库git push -u origin main\n\n","categories":["Git"],"tags":["笔记","Git"]},{"title":"操作系统笔记-Chapter 3-非连续内存","url":"/2026/02/03/OS-chapter-3/","content":"连续内存分配存在内存利用率低、容易产生内碎片外碎片等缺点，故引入非连续内存分配。\n非连续内存分配管理方法：（硬件方法）\n\n分段\n分页（用得多）\n\n\n\n1.分段（Segmentation）1.程序的分段地址空间\n把程序的代码、数据等分段，分散到多个物理空间。这种方式虽然让程序在逻辑地址上连续，但是在物理地址上是分开的。\n\n2.分段寻址方案\n 应用程序的地址是一维的逻辑地址。一维的逻辑地址需要和物理地址对应。\n一维逻辑地址由不同的段组成，将一维的地址分为两块，一块是段寻址，一块是段内偏移寻址。\n如果段号和段内偏移是分开的两个地址，则称为段寄存器+地址寄存器实现方案。如果合在一起，则称为单地址实现方案。\n\n\n段表中存放着逻辑地址与物理地址的映射关系和段的起始地址以及长度。\n当通过段号寻址到物理内存中的起始地址之后，CPU会比对该地址是否满足段表的限制（起始地址和长度），若不满足限制，说明超出了访问范围。\n2.分页（Paging）1.分页地址空间\n通过2的幂来划分物理内存至固定大小的帧，逻辑机制空间应该和物理地址空间具有相同大小的页。\n注意：物理页称作帧，逻辑页称作页。\n帧：（frame）\n假设每一帧有S个字节，那么帧内偏移就有S位。\n\n地址计算的实例：有16bit的地址空间，9bit大小的页帧，假设物理地址的帧号是3，偏移地址是6，求实际的物理地址。\n​\t9bit大小的页帧，则偏移量有2^9&#x3D;512byte。\n根据公式：物理地址&#x3D;2^9 * 3 + 6&#x3D; 1542\n页：（page）\n一个程序的逻辑地址被划分为大小相等的页\n页内偏移的大小等于帧内偏移的大小\n页的大小和页帧大小一样\n页号的大小不一定等于帧号大小\n\n2.页寻址方案\n程序运行时，CPU先寻址（逻辑地址），针对逻辑地址的页号部分，查询页表中对应页号的帧号，从而映射到物理地址。 \n3.页表（Page Table）可以简单理解为页表就是个大数组。\n页表的索引指的是page number，即页号。\n索引所对应页表项中存放着frame number。\nCPU先查询页表的起始地址，查询page number算出index，再寻址到对应的页表项，从而取出frame number，frame number叠加上offset就形成了物理地址。\n页表项除存放frame number以外还会存一些bit，这些bit可以用于表示页表项是否合法（对应物理页是否存在）。\n逻辑地址空间大小不一，有可能有一部分逻辑地址空间并没有对应到物理地址空间。\n\n地址转换\n​\tCPU先找逻辑地址，查找 (4,0) ，从低往高第五个页表，偏移量为0。查询到该页表项中有标志位和相应的帧号，帧号为00000，标志位为100。标志位的第二项就是上文所说的bit，0表示不存在对应的物理地址，反之1表示存在。可见逻辑地址 (4,0) 所对应的物理地址不存在，如果CPU访问到这个地址空间就会发出异常。\n​\t再查找 (3，1023) 这个逻辑地址，从低往高第四个页表，偏移量为1023。CPU查询到对应的标志位和帧号分别为 011 00100。说明对应物理地址存在，并且对应到物理地址中的页帧号是4。物理地址中从低到高第五个页表，并且页帧的偏移量与页的偏移量同为1023。成功对应上了物理地址。\n\n分页机制的性能问题\n​\t访问一个内存单元需要进行两次内存访问，一次获取页表项，一次用于访问数据。\n","categories":["操作系统"],"tags":["操作系统","笔记"]},{"title":"操作系统笔记-Chapter 4-虚拟内存","url":"/2026/02/03/OS-chapter-4/","content":"1.交换技术目的：当多个程序在内存中时，让正在运行的程序或者需要运行的程序获得更多的内存资源\n方法：\n\n将暂时不能运行的程序放到内存外，从而获得更多空闲内存\n把一个进程的整个地址空间的内容保存到外存（换出），将外存中的某一个进程地址空间读入到内存中（换入）。\n\n\n\n2.虚存技术在内存不够用时，可以采用覆盖技术和交换技术，但是：\n\n覆盖技术需要程序员把整个程序划分成若干个小的功能模块，并确定各模块的覆盖关系，增加了程序员的负担\n交换技术以进程作为交换单元，需要把进程的整个地址空间都换入换出，增加了处理器开销\n\n因此引入虚拟内存技术：\n虚存技术能够同时拥有前两个技术的功能：可以像覆盖技术那样不将所有内容都放在内存，但由操作系统自己来完成覆盖操作，无需程序员干涉；也可以像交换技术那样实现进程在内存外存之间的交换，但只对进程的部分内容进行交换。\n虚拟页式内存管理\n\n大部分虚拟存储系统都采用虚拟页式存储管理技术，即在页式存储管理的基础上，增加请求调页和页面置换功能。\n\n在运行过程中，如果发现要运行的程序或者要访问的数据不在内存中，则向系统发出缺页中断请求（请求调页），系统在处理这个中断时，会根据中断异常产生的地址将外存中相应的页面调入内存，使得该程序能继续运行。\n\n\n为实现调页和页面置换，需要在页表项中增加4个位来辅助：\n\n驻留位（存在位）：决定访问的数据是否在内存中。为1表示该页当前在内存中，即该表是有效的，可以使用；为1表示该页还在外存中，如果访问到此页，将会出现缺页中断。\n保护位：表示允许对该页做何种类型的访问，如只读、读写、可执行。\n修改位：表示该页是否被修改过。当进行换入换出时，根据此位来决定是否把它的内存写回外存，即不一致时需要更新。\n访问位：如果该页面被访问过，则设置此位。用于页面置换算法，如果不常被访问，则会被置换到外存。\n\n","categories":["操作系统"],"tags":["操作系统","笔记"]},{"title":"Paddle二次开发","url":"/2026/02/04/Paddle%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/","content":"Paddle二次开发wsl下训练即可\n准备数据集\n再Windows下启动PPOCRLabel\n\n\nPPOCRLabel --lang ch\n\n1.文本检测模型二次训练1.准备数据集paddlelabel标注数据集后使用以下命令划分数据集\npython gen_ocr_train_val_test.py --trainValTestRatio 7:3:0 --datasetRootPath &quot;F:\\Data\\Learning\\proj\\AI\\zifu\\train_data&quot;\n\n划分完成后会生成train_data文件夹，内容为\ntrain_data├── det│   ├── train.txt│   ├── val.txt│   └── images└── rec    ├── train.txt    ├── val.txt    └── images\n\n2.训练模型下载权重\nwget https://paddle-model-ecology.bj.bcebos.com/paddlex/official_pretrained_model/PP-OCRv5_mobile_det_pretrained.pdparams\n\n使用moblie det的配置文件，配置文件在PaddleOCR源码里\nconfigs/det/PP-OCRv5/PP-OCRv5_mobile_det.yml\n\n安装缺失依赖\npip install -r requirements.txt \n\n复制权重文件和数据集到源码文件夹，注意数据集标注文件中图片的路径，改成相对路径。\n开始训练\npython tools/train.py \\  -c configs/det/PP-OCRv5/PP-OCRv5_mobile_det.yml \\  -o Global.pretrained_model=./PP-OCRv5_mobile_det_pretrained.pdparams \\     Global.epoch_num=100 \\     Train.dataset.data_dir=./train_data \\     Train.dataset.label_file_list=[&#x27;train_data/det/train.txt&#x27;] \\     Eval.dataset.data_dir=./train_data \\     Eval.dataset.label_file_list=[&#x27;train_data/det/val.txt&#x27;]\n\n模型评估\npython tools/eval.py   -c configs/det/PP-OCRv5/PP-OCRv5_mobile_det.yml   -o Global.pretrained_model=output/PP-OCRv5_mobile_det/best_accuracy.pdparams      Eval.dataset.data_dir=./train_data      Eval.dataset.label_file_list=[&#x27;train_data/det/val.txt&#x27;]\n\n2.文本识别模型二次训练1.下载预训练模型\nwget https://paddle-model-ecology.bj.bcebos.com/paddlex/official_pretrained_model/PP-OCRv5_mobile_rec_pretrained.pdparams\n\n2.训练模型\n由于模型结果和训练流程的差异，rec的训练要比det训练慢很多。\npython tools/train.py \\  -c configs/rec/PP-OCRv5/PP-OCRv5_mobile_rec.yml \\  -o Global.pretrained_model=./PP-OCRv5_mobile_rec_pretrained.pdparams \\     Train.dataset.data_dir=./train_data \\     Train.dataset.label_file_list=[&#x27;train_data/rec/train.txt&#x27;] \\     Eval.dataset.data_dir=./train_data \\     Eval.dataset.label_file_list=[&#x27;train_data/rec/val.txt&#x27;] \\     Global.epoch_num=100\n","categories":["嵌入式AI"],"tags":["笔记","嵌入式AI"]},{"title":"RK3588上运行PaddleOCR字符识别","url":"/2026/02/04/RK3588%E4%B8%8A%E8%BF%90%E8%A1%8CPaddleOCR%E5%AD%97%E7%AC%A6%E8%AF%86%E5%88%AB/","content":"RK3588上运行PaddleOCR字符识别1.环境搭建官网：https://www.docker.com/products/docker-desktop/下载这个版本\n\n\n\nWindows下配置docker，方便wsl2中运行docker\n\nwsl-Debian下运行\n关于wsl的部署可以参考笔者另一篇文章：Windows安装WSL\ndocker ps\n\n能打印出东西并且不报错就说明docker已经安装完成。\n启动&#x2F;退出容器\n#进入docker exec -it paddle /bin/bash#退出exit/ctrl+d\n\n复制Docker的文件夹到宿主机\ndocker cp &lt;容器名或ID&gt;:&lt;容器内路径&gt; &lt;宿主机路径&gt;\n\nWindows命令行输入\nnvidia-smi\n\n查看自己电脑能支持的cuda版本\n\n拉取paddle的docker，官网\n\n选择自己的cuda版本后复制命令到wsl运行等待下载即可。\n\n下载完成\n\n运行命令构建并进入docker\ndocker run --gpus all --name paddle -it -v $PWD:/paddle ccr-2vdh3abv-pub.cnc.bj.baidubce.com/paddlepaddle/paddle:3.2.0-gpu-cuda12.6-cudnn9.5 /bin/bash\n\n\n成功进入docker后运行命令检测gpu是否可用\npython3 - &lt;&lt; &#x27;EOF&#x27;import paddleprint(&quot;Paddle:&quot;, paddle.__version__)print(&quot;GPU avail:&quot;, paddle.device.is_compiled_with_cuda())EOF\n\n打印True说明可以正常使用\n\n2.运行PC端运行模型和转换模型获取onnx模型\n在docker环境中安装paddle2onnx\npip install paddle2onnx\n\n安装推理包\n# 只希望使用基础文字识别功能（返回文字位置坐标和文本内容）python -m pip install paddleocr# 希望使用文档解析、文档理解、文档翻译、关键信息抽取等全部功能# python -m pip install &quot;paddleocr[all]&quot;\n\n运行官方的推理命令，会自动帮你下载模型\n# 运行 PP-OCRv5 推理paddleocr ocr -i https://paddle-model-ecology.bj.bcebos.com/paddlex/imgs/demo_image/general_ocr_002.png --use_doc_orientation_classify False --use_doc_unwarping False --use_textline_orientation False\n\n\n推理成功，下载的模型放在了\n/root/.paddlex/official_models/\n\n\n导出onnx模型\n# 文本检测模型 → det.onnxpaddle2onnx \\  --model_dir /root/.paddlex/official_models/PP-OCRv5_server_det \\  --model_filename inference.json \\  --params_filename inference.pdiparams \\  --save_file det.onnx \\  --opset_version 11# 文本识别模型 → rec.onnxpaddle2onnx \\  --model_dir /root/.paddlex/official_models/PP-OCRv5_server_rec \\  --model_filename inference.json \\  --params_filename inference.pdiparams \\  --save_file rec.onnx \\  --opset_version 11\n\n\n​\tonnx模型导出成功。\nonnx转rknn\n下载野火官方的模型转换程序\ngit clone https://gitee.com/LubanCat/lubancat_ai_manual_code.gitcd lubancat_ai_manual_code/example/ppocrv5/python\n\n将之前转换好的onnx模型复制到lubancat_ai_manual_code&#x2F;example&#x2F;ppocrv5&#x2F;model下\n运行脚本进行转换\npython convert_det.py ../model/det.onnx rk3588\n\n\n3.rk3588上模型部署将pc端转换好的rknn模型复制到例程目录下\n# 获取程序git clone https://gitee.com/LubanCat/lubancat_ai_manual_code.gitcd lubancat_ai_manual_code/example/ppocrv5/cpp#编译程序，cd lubancat_ai_manual_code/example/ppocrv5/cpp/./build-linux.sh -t rk3588\n\n编译成功后就可以执行命令进行识别了\n#先获取一张示例图片wget -c https://paddle-model-ecology.bj.bcebos.com/paddlex/imgs/demo_image/general_ocr_002.png#运行命令识别./rknn_ppocrv5_demo ./model/PP-OCRv5_mobile_det.rknn    ./model/PP-OCRv5_mobile_rec.rknn  ./general_ocr_002.png\n\n官方的源代码比较冗余，笔者在这里增删修改了一下源代码，方便使用。\n\n笔者的硬件环境是rk3588，修改后的代码只需要传入图片路径就能编译。\n修改的代码链接\n","categories":["嵌入式AI"],"tags":["嵌入式AI","笔记，瑞芯微"]},{"title":"YOLOv5-车牌号检测-部署到RK3588嵌入式平台","url":"/2026/02/04/YOLOv5-%E8%BD%A6%E7%89%8C%E5%8F%B7%E6%A3%80%E6%B5%8B-%E9%83%A8%E7%BD%B2%E5%88%B0RK3588%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B9%B3%E5%8F%B0/","content":"YOLOv5-车牌号检测-部署到RK3588嵌入式平台1.模型训练下载瑞芯微仓库的yolov5源码\ngit clone git@github.com:airockchip/yolov5.git\n\n下载瑞芯微onnx转rknn的源码，下载2.3.0版本\nrknn-toolkit2-2.3.0\n安装依赖\n\n\npip install -qr requirements.txt\n\n网上随便找一个车牌的数据集，在yolov5文件夹下新建datasets文件夹，放入自己的数据集。\n\ndata文件夹下添加licences.yaml文件，填入如下代码：\ntrain: /home/adas/yolov5/datasets/License-Plate/train/imagesval: /home/adas/yolov5/datasets/License-Plate/valid/images#填自己的数据集路径nc: 1names: [&#x27;License-Plate&#x27;]\n\n修改train.py\n#第569行开始parser.add_argument(&quot;--weights&quot;, type=str, default=ROOT / &quot;yolov5s.pt&quot;, help=&quot;initial weights path&quot;) //yolov5s.pt权重文件，提前下载好放入当前文件夹。parser.add_argument(&quot;--cfg&quot;, type=str, default=&quot;&quot;, help=&quot;model.yaml path&quot;)//默认配置parser.add_argument(&quot;--data&quot;, type=str, default=ROOT / &quot;data/licences.yaml&quot;, help=&quot;dataset.yaml path&quot;)//数据集路径配置文件parser.add_argument(&quot;--hyp&quot;, type=str, default=ROOT / &quot;data/hyps/hyp.scratch-low.yaml&quot;, help=&quot;hyperparameters path&quot;)//默认parser.add_argument(&quot;--epochs&quot;, type=int, default=100, help=&quot;total training epochs&quot;)//训练轮数，100就可以了，越高模型越精准同时训练时间也更久parser.add_argument(&quot;--batch-size&quot;, type=int, default=16, help=&quot;total batch size for all GPUs, -1 for autobatch&quot;)//根据自己的显卡来配置，数值越大，训练越快但显存占用越高，我RTX 4060 Laptop（8GB 显存）选择填入参数16。\n\n开始训练：\npython train.py\n\n2.测试模型测试模型这边直接把车牌裁剪出来，需要修改detect.py的一些参数。\n将\nif save_crop:    save_one_box(xyxy, imc, file=save_dir / &quot;crops&quot; / names[c] / f&quot;&#123;p.stem&#125;.jpg&quot;, BGR=True)                    \n\n改为\nif save_crop and len(det):    for *xyxy, conf, cls in reversed(det):        c = int(cls)  # 类别        crop_dir = save_dir / &quot;crops&quot; / names[c]        crop_dir.mkdir(parents=True, exist_ok=True)  # 确保目录存在        # 保存裁剪图        save_one_box(torch.tensor(xyxy), im0s.copy(), file=crop_dir / f&quot;\t\t&#123;p.stem&#125;_&#123;seen&#125;.jpg&quot;, BGR=True)\n\n运行命令\npython detect.py --weights license_best.pt --source /home/adas/yolov5/datasets/License-Plate/valid/images --save-crop --nosave\n\n打开运行结果图片，可见只截取了感兴趣区域。\n\n\n3.模型转换1.pt转onnx讲训练好的模型复制到yolov5文件夹下，把best.pt改名字为license_best.pt，执行命令将license_best.pt转license_best.onnx\npython export.py --rknpu --weight yolov5_rknn7.0_best.pt\n\n\n成功导出onnx模型。\n用可视化工具查看到有三输出，模型正常。\n\n2.onnx转rknn创建并进入虚拟环境\nconda create -n rknn230 python=3.8conda activate rknn230\n\n有关conda虚拟环境的配置可参考另外一篇文章：yolov5环境搭建、模型训练以及模型转换\n打开提前下载好的rknn-toolkit2源码，进入&#x2F;path&#x2F;to&#x2F;rknntool-2.3.0&#x2F;rknn-toolkit2-2.3.0&#x2F;rknn-toolkit2&#x2F;packages&#x2F;x86_64&#x2F;安装依赖。\npip install -r requirements_cp38-2.3.0.txt -i https://pypi.tuna.tsinghua.edu.cn/simplepip install rknn_toolkit2-2.3.0+708089d1-cp38-cp38-linux_x86_64.whl\n\n至此rknn环境配置完成。\n打开提前下载好的rknn_model_zoo文件，进入&#x2F;path&#x2F;to&#x2F;rknn_model_zoo&#x2F;examples&#x2F;yolov5&#x2F;python&#x2F;修改convert.py，将以下路径替换成自己的。\n\n修改完成后将onnx模型复制到model文件夹。\n运行命令执行转换\n#rk3588替换成自己的开发板芯片python convert.py ../model/license_best.onnx rk3588\n\n\n到这里就是转换完成了，可以看到model文件夹下出现了rknn模型。\n\n注意：如果转化中断了，下一次转换需要重新拷贝onnx文件，不然会转换失败。\n我们把rknn模型用可视化工具打开，可以发现输出和onnx模型的输出一致，至此模型转换成功。\n\n4.模型部署将转换得到的rknn文件传输到开发板端，开发板再打开自己的工程目录，将旧模型替换即可。\n","categories":["嵌入式AI"],"tags":["嵌入式AI","笔记，瑞芯微"]}]