[{"title":"操作系统笔记-Chapter 1-概论","url":"/2026/02/03/OS-chapter-1/","content":"操作系统的启动\nDISK：存放OS和Bootloader。一开始操作系统并不是直接放入内存里面，而是放到硬盘当中，由BIOS来提供支持。\n\nBIOS：基本IO处理系统。计算机开机之后，让计算机系统检测各种外设，让OS加载相应软件。\n\nBootloader：加载OS，把OS从硬盘放到内存中，使得CPU能够执行操作系统。\n\n\n\n\n\nBOIS会在内存的特定地址开始执行。\n上电之后BOIS需要执行的操作：\n\nPOST（加电自检），检查设备是否能正常工作。\n将Bootloader从硬盘放到内存中。\n寻找显卡和执行BIOS\n\n\nBootloader：\n\n寻找DISK中操作系统的起始扇区和操作系统长度。\n将操作系统对应磁盘块读到内存中。\n将CPU控制权交给OS，跳转到操作系统的起始地址执行。\n\n\n操作系统的系统调用、异常、中断定义：\n1.系统调用（来源于应用程序）\n​\t异步或者同步事件。应用程序主动向操作系统发出服务请求。\n2.异常（来源于不良的应用程序）\n​\t同步事件。非法指令或者其他坏的处理状态（如：内存出错），并非程序主动发出的请求。\n3.中断（来源于外设）\n​\t异步事件。来自不同硬件设备的计时器和网络中断。\n系统调用、中断和异常的处理机制\n中断：\n​\t硬件：\n​\t设置中断标记\n​\t\t1.将内部、外部事件设置中断标记\n​\t\t2.设置中断事件的ID，让操作系统能找到对应的处理程序\n​\t软件：\n​\t1.保存当前的处理状态，当中断服务程序执行完成后回到原来被打断的点。\n​\t2.保存完状态后，程序跳转到中断号对应的中断服务程序。\n​\t3.清除中断标记\n​\t4.恢复原本的处理状态\n异常：\n1.保存现场\n2.异常处理\n​\t1.杀死产生异常的程序\n​\t2.重新执行异常的程序\n3.恢复现场\n系统调用：\n程序访问只要是通过高层次的API接口而不是直接进行系统调用。Linux，Mac OS等用的是POSIX API，只要遵循这个机制，就可以跨平台使用。\n应用程序会通过Library Code来访问系统调用接口。\n访问到系统调用接口过后会触发操作系统从用户态转换为内核态。\n**用户态：**特权低，无法直接访问特殊的机器指令和IO。\n**内核态：**操作系统运行过程中可以执行任意一条CPU发出的指令，包括特权指令和访问IO的指令。可以完全控制整个计算机系统。\n转换为内核态后，操作系统会识别应用程序发出的系统调用参数、ID号等，并完成具体的服务。\n系统调用和函数调用的区别：\n​\t1.函数调用只是在一个栈空间中进行参数的传递，参数的返回\n​\t2.系统调用中，应用程序和操作系统内核拥有各自的堆栈。当应用程序发出系统调用后，需要切换堆栈，同时要完成特权转换。\n可见执行系统调用相比于执行函数调用开销要大很多，但是系统调用要可靠得多。\n","categories":["操作系统"],"tags":["操作系统","笔记"]},{"title":"操作系统笔记-Chapter 2-内存","url":"/2026/02/03/OS-chapter-2/","content":"1.内存分层寄存器-缓存-主存-磁盘（虚拟内存）速度由快到慢。\n\n操作系统中管理内存的不同方法\n程序重定位\n分段\n分页\n虚拟内存\n按需分页虚拟内存\n\n\n\n\n\n\n2.地址空间&amp;地址生成1.地址空间定义：物理地址空间：与硬件直接对应，如内存条、硬盘等，其管理和控制由硬件完成。\n逻辑地址空间：一个程序运行时的地址空间，相较于物理地址空间更简单，需通过操作系统将程序映射到物理地址空间。\n\nc语言和汇编语言都是人能看懂的，不带有地址，而链接文件和可执行文件中包含地址。这些地址都是逻辑地址，知识通过编译器等完成的，还没有经过操作系统。\n2.地址空间的生成​\tCPU 内部包含一个 内存管理单元 (MMU)，它负责将程序运行时产生的 逻辑地址 (Logical Address) 实时转换成内存中的 物理地址 (Physical Address)。\n​\t当 CPU 需要执行一条指令时，它会向 MMU 发出逻辑地址。MMU 通过查询由操作系统维护的 页表 (Page Table) 或 段表 (Segment Table) 等映射机制，找到该逻辑地址对应的物理地址。\n​\t获取到物理地址后，CPU 控制器（或总线接口单元）会通过 系统总线 向 主存储器 (Main Memory) 发送请求，请求获取该物理地址处存储的内容（即待执行的指令或数据）。\n​\t主存接收到请求后，将相应物理地址的内容通过总线传输回 CPU。CPU 接收到指令后，便开始执行。\n​\t操作系统 (OS) 在整个过程中扮演的关键角色是 建立和维护 这种逻辑地址到物理地址的 映射关系，确保每个进程都能安全、独立地访问其所需的内存空间。\n3.连续内存分配1.内存碎片给运行的程序分配空间之后，会出现一些无法利用的空闲空间。\n内碎片：分配单元之内使用的剩余内存空间。\n外碎片：分配单元之间未使用的内存空间\n2.动态分配操作系统把程序加载到内存中去，也就是在内存中分配一块连续的区域，让程序能成功运行。\n程序运行时需要访问数据，操作系统需要给数据分配地址空间。\n分配策略：\n\n首次分配\n\n最优分配\n\n最差适配\n\n\n**首次适配：**按顺序从第一个空闲内存块开始找\n\n\n将空闲块按地址排序\n寻找第一个合适的分区\n\n优点：简单、易于产生大的空闲块\n缺点：容易产生外部碎片\n**最优适配：**寻找整个地址空间中，最满足分配请求的空间块\n\n\n按尺寸排列空闲块列表\n寻找最适合的分区\n\n优点：当分配是小尺寸是非常有效\n缺点：容易产生微小的外部碎片\n**最差适配：**寻找整个地址空间中，与分配需求差距最大的地址空间\n\n\n按尺寸排列空闲块的列表\n寻找最大的分区\n\n优点：分配中等尺寸效果最好\n缺点：外部碎片、容易破坏打的空闲块以至于大空闲块无法被分配。\n3.压缩式与交换式碎片整理由于无论采用什么算法都会产生一定的内碎片和外碎片，故需要一个处理方法使得碎片尽量的少。\n处理方法：\n\n压缩式碎片整理\n交换式碎片整理\n\n压缩式碎片整理：调整程序位置，合并未使用的空间\n\n交换式碎片整理：\n充分利用硬盘。当程序快把内存空间占满时，没有多余空闲空间，无法使用压缩式整理碎片。此时把硬盘当作备份。\n问题：①把哪个程序换到硬盘？②什么时候进行换入换出？\n","categories":["操作系统"],"tags":["操作系统","笔记"]},{"title":"操作系统笔记-Chapter 3-非连续内存","url":"/2026/02/03/OS-chapter-3/","content":"连续内存分配存在内存利用率低、容易产生内碎片外碎片等缺点，故引入非连续内存分配。\n非连续内存分配管理方法：（硬件方法）\n\n分段\n分页（用得多）\n\n\n\n1.分段（Segmentation）1.程序的分段地址空间\n把程序的代码、数据等分段，分散到多个物理空间。这种方式虽然让程序在逻辑地址上连续，但是在物理地址上是分开的。\n\n2.分段寻址方案\n 应用程序的地址是一维的逻辑地址。一维的逻辑地址需要和物理地址对应。\n一维逻辑地址由不同的段组成，将一维的地址分为两块，一块是段寻址，一块是段内偏移寻址。\n如果段号和段内偏移是分开的两个地址，则称为段寄存器+地址寄存器实现方案。如果合在一起，则称为单地址实现方案。\n\n\n段表中存放着逻辑地址与物理地址的映射关系和段的起始地址以及长度。\n当通过段号寻址到物理内存中的起始地址之后，CPU会比对该地址是否满足段表的限制（起始地址和长度），若不满足限制，说明超出了访问范围。\n2.分页（Paging）1.分页地址空间\n通过2的幂来划分物理内存至固定大小的帧，逻辑机制空间应该和物理地址空间具有相同大小的页。\n注意：物理页称作帧，逻辑页称作页。\n帧：（frame）\n假设每一帧有S个字节，那么帧内偏移就有S位。\n\n地址计算的实例：有16bit的地址空间，9bit大小的页帧，假设物理地址的帧号是3，偏移地址是6，求实际的物理地址。\n​\t9bit大小的页帧，则偏移量有2^9&#x3D;512byte。\n根据公式：物理地址&#x3D;2^9 * 3 + 6&#x3D; 1542\n页：（page）\n一个程序的逻辑地址被划分为大小相等的页\n页内偏移的大小等于帧内偏移的大小\n页的大小和页帧大小一样\n页号的大小不一定等于帧号大小\n\n2.页寻址方案\n程序运行时，CPU先寻址（逻辑地址），针对逻辑地址的页号部分，查询页表中对应页号的帧号，从而映射到物理地址。 \n3.页表（Page Table）可以简单理解为页表就是个大数组。\n页表的索引指的是page number，即页号。\n索引所对应页表项中存放着frame number。\nCPU先查询页表的起始地址，查询page number算出index，再寻址到对应的页表项，从而取出frame number，frame number叠加上offset就形成了物理地址。\n页表项除存放frame number以外还会存一些bit，这些bit可以用于表示页表项是否合法（对应物理页是否存在）。\n逻辑地址空间大小不一，有可能有一部分逻辑地址空间并没有对应到物理地址空间。\n\n地址转换\n​\tCPU先找逻辑地址，查找 (4,0) ，从低往高第五个页表，偏移量为0。查询到该页表项中有标志位和相应的帧号，帧号为00000，标志位为100。标志位的第二项就是上文所说的bit，0表示不存在对应的物理地址，反之1表示存在。可见逻辑地址 (4,0) 所对应的物理地址不存在，如果CPU访问到这个地址空间就会发出异常。\n​\t再查找 (3，1023) 这个逻辑地址，从低往高第四个页表，偏移量为1023。CPU查询到对应的标志位和帧号分别为 011 00100。说明对应物理地址存在，并且对应到物理地址中的页帧号是4。物理地址中从低到高第五个页表，并且页帧的偏移量与页的偏移量同为1023。成功对应上了物理地址。\n\n分页机制的性能问题\n​\t访问一个内存单元需要进行两次内存访问，一次获取页表项，一次用于访问数据。\n","categories":["操作系统"],"tags":["操作系统","笔记"]},{"title":"操作系统笔记-Chapter 4-虚拟内存","url":"/2026/02/03/OS-chapter-4/","content":"1.交换技术目的：当多个程序在内存中时，让正在运行的程序或者需要运行的程序获得更多的内存资源\n方法：\n\n将暂时不能运行的程序放到内存外，从而获得更多空闲内存\n把一个进程的整个地址空间的内容保存到外存（换出），将外存中的某一个进程地址空间读入到内存中（换入）。\n\n\n\n2.虚存技术在内存不够用时，可以采用覆盖技术和交换技术，但是：\n\n覆盖技术需要程序员把整个程序划分成若干个小的功能模块，并确定各模块的覆盖关系，增加了程序员的负担\n交换技术以进程作为交换单元，需要把进程的整个地址空间都换入换出，增加了处理器开销\n\n因此引入虚拟内存技术：\n虚存技术能够同时拥有前两个技术的功能：可以像覆盖技术那样不将所有内容都放在内存，但由操作系统自己来完成覆盖操作，无需程序员干涉；也可以像交换技术那样实现进程在内存外存之间的交换，但只对进程的部分内容进行交换。\n虚拟页式内存管理\n\n大部分虚拟存储系统都采用虚拟页式存储管理技术，即在页式存储管理的基础上，增加请求调页和页面置换功能。\n\n在运行过程中，如果发现要运行的程序或者要访问的数据不在内存中，则向系统发出缺页中断请求（请求调页），系统在处理这个中断时，会根据中断异常产生的地址将外存中相应的页面调入内存，使得该程序能继续运行。\n\n\n为实现调页和页面置换，需要在页表项中增加4个位来辅助：\n\n驻留位（存在位）：决定访问的数据是否在内存中。为1表示该页当前在内存中，即该表是有效的，可以使用；为1表示该页还在外存中，如果访问到此页，将会出现缺页中断。\n保护位：表示允许对该页做何种类型的访问，如只读、读写、可执行。\n修改位：表示该页是否被修改过。当进行换入换出时，根据此位来决定是否把它的内存写回外存，即不一致时需要更新。\n访问位：如果该页面被访问过，则设置此位。用于页面置换算法，如果不常被访问，则会被置换到外存。\n\n","categories":["操作系统"],"tags":["操作系统","笔记"]},{"title":"hello","url":"/2026/02/03/hello/","content":""}]